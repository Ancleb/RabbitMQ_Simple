1. springboot使用了RabbitMQ中的IO多路复用的理念，rabbitmq官方说明推荐一个线程使用一个channel，而在web场景中线程数可能非常多，这种做法并不合适。spring对这种方案进行了优化，尽可能的复用空闲中的channel。boot默认使用CachingConnectionFactory对Connection和空闲Channel进行缓存。
    1. 当第一次有请求连接rabbitmq时，spring创建一个AMQP的connection，并使用CachingConnectionFactory将其封装并缓存起来。
    2. 然后使用这个connection，创建channel，当channel的任务执行完成则使用CachingConnectionFactory的静态子类ChannelConnectionFactoryProxy把这个channel缓存到一个空闲列表中。开启了事务的channel存放在不同的列表中。
    3. 其他线程执行任务时，CachingConnectionFactory中获取connection，然后创建channel时，会去ChannelConnectionFactoryProxy的空闲列表中寻找哪些channel是open状态。然后将寻找到的一个channel移出列表，并使用这个channel执行任务。（取出缓存中的channel这一过程是同步代码块）
    4. 任务执行完毕，将channel在缓存入空闲列表中。默认最多缓存25个channel

2. Spring会扫描容器中的所有Ex，Queue，Bindings并声明他们。
3. RabbitListenerAnnotationBeanPostProcessor类会扫描容器中所有声明的@RabbitListener，并声明其中的@Queue，@Exchange，@Binding
4. @RabbitListener标记在方法上：会将所有被标记的方法都动态代理生成一个RabbitListener侦听器实例。
5. Spring将消息的发送和接收时需要转换为byte[]的序列/反序列化操作抽象成了一个MessageConverter，其实现有 SimpleMessageConverter（默认,Serializable对象使用JDK的序列化方式）、Jackson2JsonMessageConverter 等
6. RabbitTemplate修改MessageConverter只需要在容器中注册一个MessageConverter实现类即可，MQ的AutoConfiguration会自动从容器中寻找message，converter。不同的MessageConverter不能分别作用于一条消息的发送和接收，因为他们的转化方式和对header或properties的修改不相同。
7. 在发送消息时，使用MessageConverter将消息转换成Message对象后，如果有将手动使用MessagePostProcessor修改Properties和Header。