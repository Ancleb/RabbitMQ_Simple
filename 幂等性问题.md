# 1. 概念(什么是幂等性问题)
    用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。
    举个最简单的例子，支付场景中用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常了，此时钱已经扣了，用户再次点击按钮，此时会进行二次扣款，返回结果成功。用户查询余额发现扣钱了，流水记录变成了两条。
    在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚。但是在响应客户端的时候也有可能出现网络中断或者异常等等。

# 2. 消息重复消费
    消费者在消费消息时，MQ已经把消息发送给消费者，消费者在给MQ返回ack时网络中断，故MQ未收到确认消息，该条消息会重新发给其他的消费者，或者在网络重连之后再次发送给该消费者，但实际上该消费者已经成功消费了该消息，最终造成消费者重复消费消息。

# 3. 解决思路
    MQ消费者的幂等性的解决一般使用全局唯一标识或者MQ的消息ID（deliverTag）来判断，每次消费时都判断一次该ID是否已经被消费过了。

# 4. 消费端的幂等性保障
    在海量订单生成的业务高峰期，生产端有可能就会重复生产消息，这时候消费端就要实现幂等性。即使消费端收到了多次相同的消息，但永远不会消费多次。
    业界主流的幂等性有两种操作：
    1. 唯一ID+指纹码机制，利用数据库主键去重
    2. 利用redis的原子性实现

## 4.1 唯一ID+指纹码机制
    指纹码：我们的一些规则或者时间戳加其他服务提供的唯一信息码，它并不一定使我们系统生成的，通常都是由业务中的信息拼接而来的。但是一定要保证唯一性。
    然后利用查询语句进行判断ID是否存在与数据库中。优势就是实现简单拼接，然后查询判断是否重复消费。劣势就是在高并发时期，单个数据库就会由性能瓶颈，当然也可以采用分库分表，但是这不是推荐的方式。

## 4.2 Redis原子性
    利用redis执行setnx命令，天然具有幂等性。从而实现不重复消费。
    利用消息的全局唯一ID（可以是MQ的deliverTag，publisher重复生产的消息deliverTag是不同的)作为key，如果set成功则此消息是第一次消费，否则就是一个被重复投递的消息。


















